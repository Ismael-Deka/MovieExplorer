{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar _toConsumableArray = require(\"/root/hw-milestone/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"/root/hw-milestone/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/root/hw-milestone/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _slicedToArray = require(\"/root/hw-milestone/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar percent = require('./percent');\n\nvar dataProperties = require('./data-properties');\n\nvar _require = require('./coverage-summary'),\n    CoverageSummary = _require.CoverageSummary; // returns a data object that represents empty coverage\n\n\nfunction emptyCoverage(filePath, reportLogic) {\n  var cov = {\n    path: filePath,\n    statementMap: {},\n    fnMap: {},\n    branchMap: {},\n    s: {},\n    f: {},\n    b: {}\n  };\n  if (reportLogic) cov.bT = {};\n  return cov;\n} // asserts that a data object \"looks like\" a coverage object\n\n\nfunction assertValidObject(obj) {\n  var valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;\n\n  if (!valid) {\n    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n\nvar keyFromLoc = function keyFromLoc(_ref) {\n  var start = _ref.start,\n      end = _ref.end;\n  return \"\".concat(start.line, \"|\").concat(start.column, \"|\").concat(end.line, \"|\").concat(end.column);\n};\n\nvar mergeProp = function mergeProp(aHits, aMap, bHits, bMap) {\n  var itemKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : keyFromLoc;\n  var aItems = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(aHits); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        itemHits = _Object$entries$_i[1];\n\n    var item = aMap[key];\n    aItems[itemKey(item)] = [itemHits, item];\n  }\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(bHits); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n        _key = _Object$entries2$_i[0],\n        bItemHits = _Object$entries2$_i[1];\n\n    var bItem = bMap[_key];\n    var k = itemKey(bItem);\n\n    if (aItems[k]) {\n      (function () {\n        var aPair = aItems[k];\n\n        if (bItemHits.forEach) {\n          // should this throw an exception if aPair[0] is not an array?\n          bItemHits.forEach(function (hits, h) {\n            if (aPair[0][h] !== undefined) aPair[0][h] += hits;else aPair[0][h] = hits;\n          });\n        } else {\n          aPair[0] += bItemHits;\n        }\n      })();\n    } else {\n      aItems[k] = [bItemHits, bItem];\n    }\n  }\n\n  var hits = {};\n  var map = {};\n  Object.values(aItems).forEach(function (_ref2, i) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        itemHits = _ref3[0],\n        item = _ref3[1];\n\n    hits[i] = itemHits;\n    map[i] = item;\n  });\n  return [hits, map];\n};\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\n\n\nvar FileCoverage = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n   * and empty coverage object with the specified file path or a data object that\n   * has all the required properties for a file coverage object.\n   */\n  function FileCoverage(pathOrObj) {\n    var reportLogic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, FileCoverage);\n\n    if (!pathOrObj) {\n      throw new Error('Coverage must be initialized with a path or an object');\n    }\n\n    if (typeof pathOrObj === 'string') {\n      this.data = emptyCoverage(pathOrObj, reportLogic);\n    } else if (pathOrObj instanceof FileCoverage) {\n      this.data = pathOrObj.data;\n    } else if (typeof pathOrObj === 'object') {\n      this.data = pathOrObj;\n    } else {\n      throw new Error('Invalid argument to coverage constructor');\n    }\n\n    assertValidObject(this.data);\n  }\n  /**\n   * returns computed line coverage from statement coverage.\n   * This is a map of hits keyed by line number in the source.\n   */\n\n\n  _createClass(FileCoverage, [{\n    key: \"getLineCoverage\",\n    value: function getLineCoverage() {\n      var statementMap = this.data.statementMap;\n      var statements = this.data.s;\n      var lineMap = Object.create(null);\n      Object.entries(statements).forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            st = _ref5[0],\n            count = _ref5[1];\n\n        /* istanbul ignore if: is this even possible? */\n        if (!statementMap[st]) {\n          return;\n        }\n\n        var line = statementMap[st].start.line;\n        var prevVal = lineMap[line];\n\n        if (prevVal === undefined || prevVal < count) {\n          lineMap[line] = count;\n        }\n      });\n      return lineMap;\n    }\n    /**\n     * returns an array of uncovered line numbers.\n     * @returns {Array} an array of line numbers for which no hits have been\n     *  collected.\n     */\n\n  }, {\n    key: \"getUncoveredLines\",\n    value: function getUncoveredLines() {\n      var lc = this.getLineCoverage();\n      var ret = [];\n      Object.entries(lc).forEach(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            l = _ref7[0],\n            hits = _ref7[1];\n\n        if (hits === 0) {\n          ret.push(l);\n        }\n      });\n      return ret;\n    }\n    /**\n     * returns a map of branch coverage by source line number.\n     * @returns {Object} an object keyed by line number. Each object\n     * has a `covered`, `total` and `coverage` (percentage) property.\n     */\n\n  }, {\n    key: \"getBranchCoverageByLine\",\n    value: function getBranchCoverageByLine() {\n      var branchMap = this.branchMap;\n      var branches = this.b;\n      var ret = {};\n      Object.entries(branchMap).forEach(function (_ref8) {\n        var _ret$line;\n\n        var _ref9 = _slicedToArray(_ref8, 2),\n            k = _ref9[0],\n            map = _ref9[1];\n\n        var line = map.line || map.loc.start.line;\n        var branchData = branches[k];\n        ret[line] = ret[line] || [];\n\n        (_ret$line = ret[line]).push.apply(_ret$line, _toConsumableArray(branchData));\n      });\n      Object.entries(ret).forEach(function (_ref10) {\n        var _ref11 = _slicedToArray(_ref10, 2),\n            k = _ref11[0],\n            dataArray = _ref11[1];\n\n        var covered = dataArray.filter(function (item) {\n          return item > 0;\n        });\n        var coverage = covered.length / dataArray.length * 100;\n        ret[k] = {\n          covered: covered.length,\n          total: dataArray.length,\n          coverage: coverage\n        };\n      });\n      return ret;\n    }\n    /**\n     * return a JSON-serializable POJO for this file coverage object\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.data;\n    }\n    /**\n     * merges a second coverage object into this one, updating hit counts\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\n     *  Note that the other object should have the same structure as this one (same file).\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (other.all === true) {\n        return;\n      }\n\n      if (this.all === true) {\n        this.data = other.data;\n        return;\n      }\n\n      var _mergeProp = mergeProp(this.s, this.statementMap, other.s, other.statementMap),\n          _mergeProp2 = _slicedToArray(_mergeProp, 2),\n          hits = _mergeProp2[0],\n          map = _mergeProp2[1];\n\n      this.data.s = hits;\n      this.data.statementMap = map;\n\n      var keyFromLocProp = function keyFromLocProp(x) {\n        return keyFromLoc(x.loc);\n      };\n\n      var keyFromLocationsProp = function keyFromLocationsProp(x) {\n        return keyFromLoc(x.locations[0]);\n      };\n\n      var _mergeProp3 = mergeProp(this.f, this.fnMap, other.f, other.fnMap, keyFromLocProp);\n\n      var _mergeProp4 = _slicedToArray(_mergeProp3, 2);\n\n      hits = _mergeProp4[0];\n      map = _mergeProp4[1];\n      this.data.f = hits;\n      this.data.fnMap = map;\n\n      var _mergeProp5 = mergeProp(this.b, this.branchMap, other.b, other.branchMap, keyFromLocationsProp);\n\n      var _mergeProp6 = _slicedToArray(_mergeProp5, 2);\n\n      hits = _mergeProp6[0];\n      map = _mergeProp6[1];\n      this.data.b = hits;\n      this.data.branchMap = map; // Tracking additional information about branch truthiness\n      // can be optionally enabled:\n\n      if (this.bT && other.bT) {\n        var _mergeProp7 = mergeProp(this.bT, this.branchMap, other.bT, other.branchMap, keyFromLocationsProp);\n\n        var _mergeProp8 = _slicedToArray(_mergeProp7, 2);\n\n        hits = _mergeProp8[0];\n        map = _mergeProp8[1];\n        this.data.bT = hits;\n      }\n    }\n  }, {\n    key: \"computeSimpleTotals\",\n    value: function computeSimpleTotals(property) {\n      var stats = this[property];\n\n      if (typeof stats === 'function') {\n        stats = stats.call(this);\n      }\n\n      var ret = {\n        total: Object.keys(stats).length,\n        covered: Object.values(stats).filter(function (v) {\n          return !!v;\n        }).length,\n        skipped: 0\n      };\n      ret.pct = percent(ret.covered, ret.total);\n      return ret;\n    }\n  }, {\n    key: \"computeBranchTotals\",\n    value: function computeBranchTotals(property) {\n      var stats = this[property];\n      var ret = {\n        total: 0,\n        covered: 0,\n        skipped: 0\n      };\n      Object.values(stats).forEach(function (branches) {\n        ret.covered += branches.filter(function (hits) {\n          return hits > 0;\n        }).length;\n        ret.total += branches.length;\n      });\n      ret.pct = percent(ret.covered, ret.total);\n      return ret;\n    }\n    /**\n     * resets hit counts for all statements, functions and branches\n     * in this coverage object resulting in zero coverage.\n     */\n\n  }, {\n    key: \"resetHits\",\n    value: function resetHits() {\n      var statements = this.s;\n      var functions = this.f;\n      var branches = this.b;\n      var branchesTrue = this.bT;\n      Object.keys(statements).forEach(function (s) {\n        statements[s] = 0;\n      });\n      Object.keys(functions).forEach(function (f) {\n        functions[f] = 0;\n      });\n      Object.keys(branches).forEach(function (b) {\n        branches[b].fill(0);\n      }); // Tracking additional information about branch truthiness\n      // can be optionally enabled:\n\n      if (branchesTrue) {\n        Object.keys(branchesTrue).forEach(function (bT) {\n          branchesTrue[bT].fill(0);\n        });\n      }\n    }\n    /**\n     * returns a CoverageSummary for this file coverage object\n     * @returns {CoverageSummary}\n     */\n\n  }, {\n    key: \"toSummary\",\n    value: function toSummary() {\n      var ret = {};\n      ret.lines = this.computeSimpleTotals('getLineCoverage');\n      ret.functions = this.computeSimpleTotals('f', 'fnMap');\n      ret.statements = this.computeSimpleTotals('s', 'statementMap');\n      ret.branches = this.computeBranchTotals('b'); // Tracking additional information about branch truthiness\n      // can be optionally enabled:\n\n      if (this['bt']) {\n        ret.branchesTrue = this.computeBranchTotals('bT');\n      }\n\n      return new CoverageSummary(ret);\n    }\n  }]);\n\n  return FileCoverage;\n}(); // expose coverage data attributes\n\n\ndataProperties(FileCoverage, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'bT', 'all']);\nmodule.exports = {\n  FileCoverage: FileCoverage\n};","map":{"version":3,"sources":["/root/hw-milestone/node_modules/istanbul-lib-coverage/lib/file-coverage.js"],"names":["percent","require","dataProperties","CoverageSummary","emptyCoverage","filePath","reportLogic","cov","path","statementMap","fnMap","branchMap","s","f","b","bT","assertValidObject","obj","valid","Error","Object","keys","join","keyFromLoc","start","end","line","column","mergeProp","aHits","aMap","bHits","bMap","itemKey","aItems","entries","key","itemHits","item","bItemHits","bItem","k","aPair","forEach","hits","h","undefined","map","values","i","FileCoverage","pathOrObj","data","statements","lineMap","create","st","count","prevVal","lc","getLineCoverage","ret","l","push","branches","loc","branchData","dataArray","covered","filter","coverage","length","total","other","all","keyFromLocProp","x","keyFromLocationsProp","locations","property","stats","call","v","skipped","pct","functions","branchesTrue","fill","lines","computeSimpleTotals","computeBranchTotals","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\nconst dataProperties = require('./data-properties');\nconst { CoverageSummary } = require('./coverage-summary');\n\n// returns a data object that represents empty coverage\nfunction emptyCoverage(filePath, reportLogic) {\n    const cov = {\n        path: filePath,\n        statementMap: {},\n        fnMap: {},\n        branchMap: {},\n        s: {},\n        f: {},\n        b: {}\n    };\n    if (reportLogic) cov.bT = {};\n    return cov;\n}\n\n// asserts that a data object \"looks like\" a coverage object\nfunction assertValidObject(obj) {\n    const valid =\n        obj &&\n        obj.path &&\n        obj.statementMap &&\n        obj.fnMap &&\n        obj.branchMap &&\n        obj.s &&\n        obj.f &&\n        obj.b;\n    if (!valid) {\n        throw new Error(\n            'Invalid file coverage object, missing keys, found:' +\n                Object.keys(obj).join(',')\n        );\n    }\n}\n\nconst keyFromLoc = ({ start, end }) =>\n    `${start.line}|${start.column}|${end.line}|${end.column}`;\n\nconst mergeProp = (aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {\n    const aItems = {};\n    for (const [key, itemHits] of Object.entries(aHits)) {\n        const item = aMap[key];\n        aItems[itemKey(item)] = [itemHits, item];\n    }\n    for (const [key, bItemHits] of Object.entries(bHits)) {\n        const bItem = bMap[key];\n        const k = itemKey(bItem);\n\n        if (aItems[k]) {\n            const aPair = aItems[k];\n            if (bItemHits.forEach) {\n                // should this throw an exception if aPair[0] is not an array?\n                bItemHits.forEach((hits, h) => {\n                    if (aPair[0][h] !== undefined) aPair[0][h] += hits;\n                    else aPair[0][h] = hits;\n                });\n            } else {\n                aPair[0] += bItemHits;\n            }\n        } else {\n            aItems[k] = [bItemHits, bItem];\n        }\n    }\n    const hits = {};\n    const map = {};\n\n    Object.values(aItems).forEach(([itemHits, item], i) => {\n        hits[i] = itemHits;\n        map[i] = item;\n    });\n\n    return [hits, map];\n};\n\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\nclass FileCoverage {\n    /**\n     * @constructor\n     * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n     * and empty coverage object with the specified file path or a data object that\n     * has all the required properties for a file coverage object.\n     */\n    constructor(pathOrObj, reportLogic = false) {\n        if (!pathOrObj) {\n            throw new Error(\n                'Coverage must be initialized with a path or an object'\n            );\n        }\n        if (typeof pathOrObj === 'string') {\n            this.data = emptyCoverage(pathOrObj, reportLogic);\n        } else if (pathOrObj instanceof FileCoverage) {\n            this.data = pathOrObj.data;\n        } else if (typeof pathOrObj === 'object') {\n            this.data = pathOrObj;\n        } else {\n            throw new Error('Invalid argument to coverage constructor');\n        }\n        assertValidObject(this.data);\n    }\n\n    /**\n     * returns computed line coverage from statement coverage.\n     * This is a map of hits keyed by line number in the source.\n     */\n    getLineCoverage() {\n        const statementMap = this.data.statementMap;\n        const statements = this.data.s;\n        const lineMap = Object.create(null);\n\n        Object.entries(statements).forEach(([st, count]) => {\n            /* istanbul ignore if: is this even possible? */\n            if (!statementMap[st]) {\n                return;\n            }\n            const { line } = statementMap[st].start;\n            const prevVal = lineMap[line];\n            if (prevVal === undefined || prevVal < count) {\n                lineMap[line] = count;\n            }\n        });\n        return lineMap;\n    }\n\n    /**\n     * returns an array of uncovered line numbers.\n     * @returns {Array} an array of line numbers for which no hits have been\n     *  collected.\n     */\n    getUncoveredLines() {\n        const lc = this.getLineCoverage();\n        const ret = [];\n        Object.entries(lc).forEach(([l, hits]) => {\n            if (hits === 0) {\n                ret.push(l);\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * returns a map of branch coverage by source line number.\n     * @returns {Object} an object keyed by line number. Each object\n     * has a `covered`, `total` and `coverage` (percentage) property.\n     */\n    getBranchCoverageByLine() {\n        const branchMap = this.branchMap;\n        const branches = this.b;\n        const ret = {};\n        Object.entries(branchMap).forEach(([k, map]) => {\n            const line = map.line || map.loc.start.line;\n            const branchData = branches[k];\n            ret[line] = ret[line] || [];\n            ret[line].push(...branchData);\n        });\n        Object.entries(ret).forEach(([k, dataArray]) => {\n            const covered = dataArray.filter(item => item > 0);\n            const coverage = (covered.length / dataArray.length) * 100;\n            ret[k] = {\n                covered: covered.length,\n                total: dataArray.length,\n                coverage\n            };\n        });\n        return ret;\n    }\n\n    /**\n     * return a JSON-serializable POJO for this file coverage object\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * merges a second coverage object into this one, updating hit counts\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\n     *  Note that the other object should have the same structure as this one (same file).\n     */\n    merge(other) {\n        if (other.all === true) {\n            return;\n        }\n\n        if (this.all === true) {\n            this.data = other.data;\n            return;\n        }\n\n        let [hits, map] = mergeProp(\n            this.s,\n            this.statementMap,\n            other.s,\n            other.statementMap\n        );\n        this.data.s = hits;\n        this.data.statementMap = map;\n\n        const keyFromLocProp = x => keyFromLoc(x.loc);\n        const keyFromLocationsProp = x => keyFromLoc(x.locations[0]);\n\n        [hits, map] = mergeProp(\n            this.f,\n            this.fnMap,\n            other.f,\n            other.fnMap,\n            keyFromLocProp\n        );\n        this.data.f = hits;\n        this.data.fnMap = map;\n\n        [hits, map] = mergeProp(\n            this.b,\n            this.branchMap,\n            other.b,\n            other.branchMap,\n            keyFromLocationsProp\n        );\n        this.data.b = hits;\n        this.data.branchMap = map;\n\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this.bT && other.bT) {\n            [hits, map] = mergeProp(\n                this.bT,\n                this.branchMap,\n                other.bT,\n                other.branchMap,\n                keyFromLocationsProp\n            );\n            this.data.bT = hits;\n        }\n    }\n\n    computeSimpleTotals(property) {\n        let stats = this[property];\n\n        if (typeof stats === 'function') {\n            stats = stats.call(this);\n        }\n\n        const ret = {\n            total: Object.keys(stats).length,\n            covered: Object.values(stats).filter(v => !!v).length,\n            skipped: 0\n        };\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    computeBranchTotals(property) {\n        const stats = this[property];\n        const ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.values(stats).forEach(branches => {\n            ret.covered += branches.filter(hits => hits > 0).length;\n            ret.total += branches.length;\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    /**\n     * resets hit counts for all statements, functions and branches\n     * in this coverage object resulting in zero coverage.\n     */\n    resetHits() {\n        const statements = this.s;\n        const functions = this.f;\n        const branches = this.b;\n        const branchesTrue = this.bT;\n        Object.keys(statements).forEach(s => {\n            statements[s] = 0;\n        });\n        Object.keys(functions).forEach(f => {\n            functions[f] = 0;\n        });\n        Object.keys(branches).forEach(b => {\n            branches[b].fill(0);\n        });\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (branchesTrue) {\n            Object.keys(branchesTrue).forEach(bT => {\n                branchesTrue[bT].fill(0);\n            });\n        }\n    }\n\n    /**\n     * returns a CoverageSummary for this file coverage object\n     * @returns {CoverageSummary}\n     */\n    toSummary() {\n        const ret = {};\n        ret.lines = this.computeSimpleTotals('getLineCoverage');\n        ret.functions = this.computeSimpleTotals('f', 'fnMap');\n        ret.statements = this.computeSimpleTotals('s', 'statementMap');\n        ret.branches = this.computeBranchTotals('b');\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this['bt']) {\n            ret.branchesTrue = this.computeBranchTotals('bT');\n        }\n        return new CoverageSummary(ret);\n    }\n}\n\n// expose coverage data attributes\ndataProperties(FileCoverage, [\n    'path',\n    'statementMap',\n    'fnMap',\n    'branchMap',\n    's',\n    'f',\n    'b',\n    'bT',\n    'all'\n]);\n\nmodule.exports = {\n    FileCoverage\n};\n"]},"metadata":{},"sourceType":"script"}